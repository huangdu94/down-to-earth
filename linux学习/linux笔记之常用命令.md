## 常用快捷键
+ `Ctrl+C`终止当前命令
+ `Ctrl+D`退出当前终端
+ `Ctrl+Z`暂停当前进程
+ `Ctrl+L`清屏
+ `Ctrl+S`暂停该终端，阻止向该终端输出
+ `Ctrl+Q`恢复向终端输出
+ `Tab`补全命令
## 查看文档
+ `man`查看手册
+ 其它命令`info` `help`
## 一、文件与目录管理
### 1.1 常见Linux目录名称
|目录|用途|
|:-|:-|
|/|虚拟目录的根目录。通常不会在这里存储文件|
|/bin| (binaries) 二进制目录，存放许多用户级的GNU工具|
|/boot|启动目录，存放启动文件|
|/dev|设备目录，Linux在这里创建设备节点|
|/etc| (etcetera) 系统配置文件目录|
|/home|主目录，Linux在这里创建用户目录|
|/lib|库目录，存放系统和应用程序的库文件|
|/media|媒体目录，可移动媒体设备的常用挂载点|
|/mnt|挂载目录，另一个可移动媒体设备的常用挂载点|
|/opt|可选目录，常用于存放第三方软件包和数据文件|
|/proc|进程目录，存放现有硬件及当前进程的相关信息|
|/root|root用户的主目录|
|/sbin| (super user binaries)系统二进制目录，存放许多GNU管理员级工具|
|/run|运行目录，存放系统运作时的运行时数据|
|/srv|服务目录，存放本地服务的相关文件|
|/sys|系统目录，存放系统硬件信息的相关文件|
|/tmp|临时目录，可以在该目录中创建和删除临时工作文件|
|/usr| (unix shared resources) 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里|
|/var|可变目录，用以存放经常变化的文件，比如日志文件|
### 1.2 基本命令
> + 绝对路径，由根目录/写起
> + 相对路径，不是由 / 写起
>   + `.`当前目录
>   + `..`当前目录的父目录
+ `ls`查看某个目录或者某个文件
  + `-a`列出隐藏的
  + `-l`详细信息(共显示了9列内容，第1列10位：第1位文件类型，-普通文件，d目录，l连接文件，c串行端口设备，s套接字文件；后9位3位为一组，分别代表所有主、所在组、其他用户对该文件的权限，rwx分别为可读、可写、可执行)
  + `-d`只显示目录
  + `-lu` `-lc` `-l`分别列出文件的atime（读取或执行文件时更改）/ctime（更改权限时更改）/mtime（修改文件内容时更改）
+ `cd`进入到某一个目录
+ `pwd`查看当前所在目录
+ `touch`没有文件创建，有的话改变文件的访问时间
+ `cp`复制
  + `-r`递归复制，拷贝目录
  + `-i`询问是否覆盖
+ `ln`
  + `-s`如果不加就是建立硬连接，加上就建立软连接
+ `mv`移动，重命名
+ `rm`删除目录或者文件
  + `-f`删除不存在的文件不会报错
  + `-r`删除一串
  + `-i`询问是否确定删除
+ `mkdir`创建一个目录
  + `-m`制定要创建目录的权限
  + `-p`创一串目录
+ `rmdir`删除一个空目录
  + `-p`删除一串空目录
+ `file`查看文件类型
+ `cat`读一个文件，并把读出的内容打印到当前屏幕上
  + `-n`显示行号
  + `-A`显示所有东西出来 
+ `tac`反向打印文件内容
+ `more` `less` 查看文件内容（比较多的时候）
+ `head`显示文件前十行
  + `-n`显示多少行
+ `tail`显示文件后十行
  + `-n`显示多少行
  + `-f`动态显示
### 1.3 处理数据文件
#### 1.3.1 排序数据
+ `sort`排序数据
  + `-n`按值排序
  + `-M`按月排序（三字符月份名，例Jan）
  + `-t`指定分隔符
  + `-k`指定用来排序的列号
  + `-r`反序排序
#### 1.3.2 搜索数据
+ `grep`搜索数据
  + `-v`搜索不匹配模式的行
  + `-n`显示所在行号
  + `-c`返回匹配了多少行
  + `-e`指定多个模式
+ `egrep`支持POSIX扩展正则表达式
+ `fgrep`支持模式由文件指定
#### 1.3.3 压缩数据
> + Linux环境中打包压缩文件的扩展名`tar` `gz` `tar.gz` `bz2` `tar.bz2` `xz` `tar.xz`统称为`tar`包
> + 压缩比      `gz`<`bz2`<`xz`
> + 压缩速度  `gz`>`bz2`>`xz`
> + 对于Linux系统来说文件扩展名没有任何卵用，但是便于识别理解
> + 打包：将许多文件和目录打包成一个文件
> + 压缩：把大文件或目录通过压缩算法变成一个较小的文件
+ `compress` `uncompress`
+ `gzip` `gunzip` `zcat`（只对单个文件压缩）
  + `-c`将压缩输出到stdout
  + `-d`解压缩
  + `-v`详细信息
  + `-#`压缩比1-9
+ `bzip2` `bunzip2` `bzcat` `bzip2recover`（只对单个文件压缩）
  + `-k`保留原文件
+ `zip` `unzip`
+ `tar`打包、压缩一个命令全搞定（版本稍高的tar命令，选项前的`-`是可选的）。
  + `tar -cvf filename.tar 源文件`
  + `tar -xvf filename [-C 绝对路径]`
  + `tar -tvf filename.tar`
  + 指定压缩算法：`z`代表`gz`，`j`代表`bz2`，`J`代表`xz`
## 二、程序与磁盘管理
+ `ps`查看进程（支持三种参数：Unix风格的参数，前面加单破折线；BSD风格的参数，前面不加破折线；GNU风格的长参数，前面加双破折线）
  + `-elf`显示所有进程完整格式输出（显示长列表）
  + `l`显示额外信息（比`-l`更多）
  + `--forest`显示进程的层级信息
+ `top`实时展示进程
  + `f`选择输出排序字段
  + `d`修改轮询间隔
  + `q`退出top
+ `kill`可通过PID给进程发信号
+ `killall`支持通过进程名来批量结束进程（使用通配符）  
***
|信号|名称|描述| 
|:-:| :-: | :-:| 
|1|HUP|挂起|
|2|INT|中断|
|3|QUIT|结束运行|
|9|KILL|无条件终止|
|11|SEGV|段错误|
|15|TERM|尽可能终止|
|17|STOP|无条件停止运行，但不终止|
|18|TSTP|停止或暂停，但继续在后台运行|
|19|CONT|在STOP或TSTP之后恢复执行|
***
+ `mount`挂载 `unmount`卸载
+ `df`查看已挂载磁盘的总容量、使用容量、剩余容量（默认以k为单位显示）
  + `-h`使用合适的单位显示（易读）
  + `-i`使用inodes显示结果
+ `du`用来查看某个目录所占空间大小
  + `-h`使用合适的单位显示（易读）
  + `-a`全部文件与目录大小都列出来
  + `-c`最后加总合
  + `-s`只列出总和
+ `fdisk`
  + `-l`后边不跟设备名会直接列出系统中所有的磁盘设备以及分区表，加上设备名会列出该设备的分区表
  + 不加`-l`则进入另一个模式，在该模式下，可以对磁盘进行分区操作
+ `mkfs`磁盘格式化
  + `-t`指定文件系统格式
+ `fsck`磁盘校验  
## 三、理解shell
### 3.1 shell的类型
+ `bash` `tcsh` `dash`
+ 默认的系统shell`sh`，一般软连接到`bash`（也有软连接到`dash`）
+ 用户登录系统的默认shell在`/etc/passwd`文件的第7个字段中记录（这里说的shell与`sh`不同）
### 3.2 shell的父子关系
+ 在一个shell中继续运行shell，可以形成shell间的嵌套关系（父子结构）
+ `exit`退出当前shell
+ 可以在一行中指定一系列的命令，多个命令用`;`隔开（命令列表）
+ 将命令列表用`()`括起来，则构成进程列表（系统会创建子shell运行进程列表）
  + `$BASH_SUBSHELL`环境变量可以看到当前shell的层级（0父shell，1子shell，2孙子shell...）
  + 进程列表可以嵌套
+ 命令后面加`&`可以后台运行（进程列表也可以加）
+ `jobs`显示后台作业信息
  + `-l`显示进程pid
+ 协程（在后台生成一个子shell，并在这个子shell中执行命令）
  + 默认名写法`coproc sleep 10`
  + 自定义名写法`coproc My_Job { sleep 10; }`
### 3.3 理解shell的内建命令
+ 外部命令会创建一个子进程运行（衍生），内建命令不会，所以内建命令效率更高
+ `which`用来查找一个命令的绝对路径（只能用来查找PATH环境变量中出现的路径下的可执行文件）
+ `type`查看一个命令是否为内建命令
  + `-a`如果该命令有多个版本则都显示
+ `history`历史命令列表
  + `~/.bash_history`历史命令保存文件
  + `-a`强制刷新文件
  + `-n`强制读取文件
  + `!!`最近一条命令 `!-n`最近第n条命令 `!n`第n条命令
+ `alias`用来设置指令的别名
  + 例：`alias ll=‘ls -l’`
  + `-p`查看当前可用的别名
  + 使用绝对路径的命令则不会被alias
+ `unalias`解除别名
## 四、Linux环境变量
> bash shell用一个叫作环境变量（environment variable）的特性来存储有关shell会话和工作环境的信息。这项特性允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。  
> 在bash shell中，环境变量分为两类：
> + 全局变量：全局环境变量对于shell会话和所有生成的子shell都是可见的。
> + 局部变量：局部变量则只对创建它们的shell可见。  
### 4.1 查看环境变量
+ `printenv`查看全局变量
  + 后跟环境变量名，可查看个别环境变量的值。例：`printenv HOME`
+ `env`查看全局变量（`env`有`printenv`没有的功能）
+ 引用某个环境变量的值，在变量前面加`$`
  + `echo $HOME`使用echo显示变量值
  + `ls $HOME`变量作为命令行参数
+ `set`显示所有环境变量，包括局部变量、全局变量以及用户定义变量
### 4.2 设置环境变量
+ 规范：局部变量使用小写字母命名，全局变量使用大写字母命名
+ `my_variable=Hello`创建局部变量
  + 等号两边不能有空格
  + 变量名只能由英、数字以及下划线组成，而且不能以数字开头
  + `my_variable="Hello World"`当变量内容带有特殊字符时（例如空格），需要加上单引号，内容中带有单引号用双引号
+ `export my_variable`创建全局变量
  + 子shell中对全局变量的修改，不会反映到父shell中
+ `unset my_variable`删除环境变量
  + 子shell中对全局变量的删除，不会反映到父shell中
+ bash shell有一些默认的系统环境变量，这些变量已经定义好了（但不一定有值）
  + 例：`HOME` `PATH` `BASH_ENV` `BASH_VERSINFO`
+ `PATH`环境变量定义了用于进行命令和程序查找的目录（使用外部命令时，shell必须搜索系统来找到对应的程序）
  + `PATH`中多个目录由`:`分隔
  + `PATH=$PATH:/home/christine/Scripts`在原有的`PATH`中继续增加目录
+ 以上方法对环境变量的修改只能持续到退出或重启系统
### 4.3 持久化环境变量
+ 启动shell的三种方式
  1. 登录时作为默认登录shell
  2. 作为非登录shell的交互式shell
  3. 作为运行脚本的非交互shell
+ 登录shell
  1. `/etc/profile`bash shell默认主启动文件（登录系统时，执行该文件中命令）
    + 导出了一些系统环境变量
    + 遍历执行`/etc/profile.d`中所有`sh`文件（一种环境变量持久化思路，不推荐直接改主启动文件）
  2. 根据登录的用户来决定的启动文件（在用户的`HOME`目录下）
    + `$HOME`和`~`的作用一样，表示当前用户的主目录
    + shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略
      1. `.bash_profile`
      2. `.bash_login`
      3. `.profile`
    + 以上文件一般会间接调用`.bashrc`文件
+ 交互式shell进程，执行`.bashrc`文件
  + 执行`/etc/bashrc`文件
  + 为用户提供一个定制自己的命令别名和私有脚本函数的地方
+ 非交互式shell，检查`BASH_ENV`环境变量，该环境变量指定了启动时要执行的文件
### 4.4 数组变量
+ `mytest=(one two three four five)`定义一个数组变量
+ `echo $mytest`只会展示数组变量的第一个值
+ `echo ${mytest[2]}`展示数组变量索引是2的值（从0开始）
+ `echo ${mytest[*]}`展示整个数组
+ `mytest[2]=seven`改变某个索引的值
+ `unset mytest[2]`删除某个索引的值（删除后那个位置上的值是空的，但是还在）
+ `unset mytest`删除整个数组
## 五、Linux文件权限
chgrp 组名 文件名 修改文件所在组
chown [-R] 用户名[:组名] 文件名 -R用于目录，级联更改 更改文件所在主/组
useradd 增加一个账户
chmod [-R] xyz 文件名 其中xyz遵循r4w2x1
或者 u/g/o +/-/= r/w/x
umask 数值代表的含义为，上边两条规则中的默认值（文件为666，目录为777）需要减掉的权限。可以在/etc/bashrc里面修改
chattr 修改文件的特殊属性
lsattr 列出文件/目录的特殊属性
### 认识/etc/passwd和/etc/shadow
+ /etc/passwd (7个字段)
  1. 用户名
  2. 账号口令(x)
  3. uid用户标识号
  4. gid组标识号
  5. findger注释说明
  6. 用户home
  7. shell
+ /etc/shadow(9个字段)
  1. 用户名
  2. 用户密码
  3. 上次更改密码的日期
  4. 要过多少天才能改密码
  5. 密码多少天后到期
  6. 密码警告期限
  7. 账号失效期_密码失效后
  8. 账号的生命周期
  9. 10.保留

groupadd groupdel useradd userdel 新增/删除组 新增/删除用户
chfn 更改用户的finger
passwd[username] 修改用户密码（默认修改当前用户的密码）
groups[username] 查看自己属于哪个用户组
usermod 可用来修改用户账号的各项设定

用户身份切换
su [-] username 加-切换用户后跳到该用户的家目录
echo $LOGNAME	查看当前登录的用户名
sudo	执行一个root才能执行的命令 别的用户使用sudo 需要visudo命令编辑 /etc/sudoers

***
如何正确关机
`who netstat -a ps -aux shutdown`
系统的远程登录 `ssh` windows常用软件 `Putty`
echo	打印	>重定向 >>追加

在linux下搜索一个文件
whereis locate 通过查找预先生成的文件列表库来告诉用户要查找的文件在哪里
find [路径][参数]
-atime读取或执行文件时更改 -ctime更改权限...时更改 -mtime写入文件时随文件内容修改更改 +n 大于n天
-name filename	直接查找该文件名的文件
-type type	通过文件类型查找
———————————————————————————————————————————————————————————
vi不会显示颜色 vim会显示颜色

vim的三种模式：一般模式、编辑模式、命令模式。
一般模式：上下移动光标；删除某个字符；删除某行；复制、粘贴一行或者多行。
编辑模式：一般模式下，是不可以修改某一个字符的，只能到编辑模式。ESC
命令模式：搜索某个字符或者字符串，也可以保存、替换、退出、显示行号等等。
———————————————————————————————————————————————————————————
安装	如何在linux系统下安装一个软件

RPM	"Redhat Package Manager" Redhat公司开发出来的

rpm -i安装 -v可视化 -h显示安装进度 filename --force覆盖也要安装 --nodeps没有也要安装	安装一个rpm包
rpm -Uvh filename 	升级一个rpm包
rpm -qa | grep file	-q查询 -a查询所有安装包	（查询一个包是否安装，不带有平台信息以及后缀名的）
	grep	用来过滤某个关键词的工具
	|	管道符，用来把前面运行的结果传递给后面的命令
rpm -e filename	卸载一个rpm包
rpm -ql 包名	列出一个rpm包安装的文件
rpm -qf 文件的绝对路径	列出某一个文件属于哪个rpm包
`命令`	引用反引号内命令执行的结果

yum list 列出所有可用的rpm包
yum search [相关关键词]	搜索一个rpm包
yum install [-y] [rpm 包名] -y就不会有太多询问信息
yum remove [-y] [rpm 包名]
yum update [-y] [rpm 包名]
使用本地光盘制作一个yum源

安装源码包 1.下载一个源码包 2.解压源码包 3.配置相关的选项 4.进行编译 5.安装
wget 下载命令 约定最好把所有下载的源码包放到/usr/local/src/目录下 源码包安装在/usr/local/目录下
echo $? 判断上一步有没有执行成功，如果是0则表示成功
./config --help 可以查看可用的选项
回车后执行check操作，check完成后生成了Makefile文件
make 进行编译
make install 会创建相应的目录文件