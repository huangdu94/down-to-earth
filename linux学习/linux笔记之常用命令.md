## 常用快捷键
+ `Ctrl+C`终止当前命令
+ `Ctrl+D`退出当前终端
+ `Ctrl+Z`暂停当前进程
+ `Ctrl+L`清屏
+ `Ctrl+S`暂停该终端，阻止向该终端输出
+ `Ctrl+Q`恢复向终端输出
+ `Tab`补全命令
## 查看文档
+ `man`查看手册
+ 其它命令`info` `help`
## 一、文件与目录管理
### 1.1 常见Linux目录名称
|目录|用途|
|:-|:-|
|/|虚拟目录的根目录。通常不会在这里存储文件|
|/bin| (binaries) 二进制目录，存放许多用户级的GNU工具|
|/boot|启动目录，存放启动文件|
|/dev|设备目录，Linux在这里创建设备节点|
|/etc| (etcetera) 系统配置文件目录|
|/home|主目录，Linux在这里创建用户目录|
|/lib|库目录，存放系统和应用程序的库文件|
|/media|媒体目录，可移动媒体设备的常用挂载点|
|/mnt|挂载目录，另一个可移动媒体设备的常用挂载点|
|/opt|可选目录，常用于存放第三方软件包和数据文件|
|/proc|进程目录，存放现有硬件及当前进程的相关信息|
|/root|root用户的主目录|
|/sbin| (super user binaries)系统二进制目录，存放许多GNU管理员级工具|
|/run|运行目录，存放系统运作时的运行时数据|
|/srv|服务目录，存放本地服务的相关文件|
|/sys|系统目录，存放系统硬件信息的相关文件|
|/tmp|临时目录，可以在该目录中创建和删除临时工作文件|
|/usr| (unix shared resources) 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里|
|/var|可变目录，用以存放经常变化的文件，比如日志文件|
### 1.2 基本命令
> + 绝对路径，由根目录/写起
> + 相对路径，不是由 / 写起
>   + `.`当前目录
>   + `..`当前目录的父目录
+ `ls`查看某个目录或者某个文件
  + `-a`列出隐藏的
  + `-l`详细信息(共显示了9列内容，第1列10位：第1位文件类型，-普通文件，d目录，l连接文件，c串行端口设备，s套接字文件；后9位3位为一组，分别代表所有主、所在组、其他用户对该文件的权限，rwx分别为可读、可写、可执行。s为SUID或SGID置位，t粘着位置位，如果是大写的话则代表不可执行，小写代表可执行，因为该位表示占用了执行位)
  + `-d`只显示目录
  + `-lu` `-lc` `-l`分别列出文件的atime（读取或执行文件时更改）/ctime（更改权限时更改）/mtime（修改文件内容时更改）
+ `cd`进入到某一个目录
+ `pwd`查看当前所在目录
+ `touch`没有文件创建，有的话改变文件的访问时间
+ `cp`复制
  + `-r`递归复制，拷贝目录
  + `-i`询问是否覆盖
+ `ln`
  + `-s`如果不加就是建立硬连接，加上就建立软连接
+ `mv`移动，重命名
+ `rm`删除目录或者文件
  + `-f`删除不存在的文件不会报错
  + `-r`删除一串
  + `-i`询问是否确定删除
+ `mkdir`创建一个目录
  + `-m`制定要创建目录的权限
  + `-p`创一串目录
+ `rmdir`删除一个空目录
  + `-p`删除一串空目录
+ `file`查看文件类型
+ `cat`读一个文件，并把读出的内容打印到当前屏幕上
  + `-n`显示行号
  + `-A`显示所有东西出来 
+ `tac`反向打印文件内容
+ `more` `less` 查看文件内容（比较多的时候）
+ `head`显示文件前十行
  + `-n`显示多少行
+ `tail`显示文件后十行
  + `-n`显示多少行
  + `-f`动态显示
### 1.3 处理数据文件
#### 1.3.1 排序数据
+ `sort`排序数据
  + `-n`按值排序
  + `-M`按月排序（三字符月份名，例Jan）
  + `-t`指定分隔符
  + `-k`指定用来排序的列号
  + `-r`反序排序
#### 1.3.2 搜索数据
+ `grep`搜索数据
  + `-v`搜索不匹配模式的行
  + `-n`显示所在行号
  + `-c`返回匹配了多少行
  + `-e`指定多个模式
+ `egrep`支持POSIX扩展正则表达式
+ `fgrep`支持模式由文件指定
#### 1.3.3 压缩数据
> + Linux环境中打包压缩文件的扩展名`tar` `gz` `tar.gz` `bz2` `tar.bz2` `xz` `tar.xz`统称为`tar`包
> + 压缩比      `gz`<`bz2`<`xz`
> + 压缩速度  `gz`>`bz2`>`xz`
> + 对于Linux系统来说文件扩展名没有任何卵用，但是便于识别理解
> + 打包：将许多文件和目录打包成一个文件
> + 压缩：把大文件或目录通过压缩算法变成一个较小的文件
+ `compress` `uncompress`
+ `gzip` `gunzip` `zcat`（只对单个文件压缩）
  + `-c`将压缩输出到stdout
  + `-d`解压缩
  + `-v`详细信息
  + `-#`压缩比1-9
+ `bzip2` `bunzip2` `bzcat` `bzip2recover`（只对单个文件压缩）
  + `-k`保留原文件
+ `zip` `unzip`
+ `tar`打包、压缩一个命令全搞定（版本稍高的tar命令，选项前的`-`是可选的）。
  + `tar -cvf filename.tar 源文件`
  + `tar -xvf filename [-C 绝对路径]`
  + `tar -tvf filename.tar`
  + 指定压缩算法：`z`代表`gz`，`j`代表`bz2`，`J`代表`xz`
## 二、程序与磁盘管理
+ `ps`查看进程（支持三种参数：Unix风格的参数，前面加单破折线；BSD风格的参数，前面不加破折线；GNU风格的长参数，前面加双破折线）
  + `-elf`显示所有进程完整格式输出（显示长列表）
  + `l`显示额外信息（比`-l`更多）
  + `--forest`显示进程的层级信息
+ `top`实时展示进程
  + `f`选择输出排序字段
  + `d`修改轮询间隔
  + `q`退出top
+ `kill`可通过PID给进程发信号
+ `killall`支持通过进程名来批量结束进程（使用通配符）  
***
|信号|名称|描述| 
|:-:| :-: | :-:| 
|1|HUP|挂起|
|2|INT|中断|
|3|QUIT|结束运行|
|9|KILL|无条件终止|
|11|SEGV|段错误|
|15|TERM|尽可能终止|
|17|STOP|无条件停止运行，但不终止|
|18|TSTP|停止或暂停，但继续在后台运行|
|19|CONT|在STOP或TSTP之后恢复执行|
***
+ `mount`挂载 `unmount`卸载
+ `df`查看已挂载磁盘的总容量、使用容量、剩余容量（默认以k为单位显示）
  + `-h`使用合适的单位显示（易读）
  + `-i`使用inodes显示结果
+ `du`用来查看某个目录所占空间大小
  + `-h`使用合适的单位显示（易读）
  + `-a`全部文件与目录大小都列出来
  + `-c`最后加总合
  + `-s`只列出总和
## 三、理解shell
### 3.1 shell的类型
+ `bash` `tcsh` `dash`
+ 默认的系统shell`sh`，一般软连接到`bash`（也有软连接到`dash`）
+ 用户登录系统的默认shell在`/etc/passwd`文件的第7个字段中记录（这里说的shell与`sh`不同）
### 3.2 shell的父子关系
+ 在一个shell中继续运行shell，可以形成shell间的嵌套关系（父子结构）
+ `exit`退出当前shell
+ 可以在一行中指定一系列的命令，多个命令用`;`隔开（命令列表）
+ 将命令列表用`()`括起来，则构成进程列表（系统会创建子shell运行进程列表）
  + `$BASH_SUBSHELL`环境变量可以看到当前shell的层级（0父shell，1子shell，2孙子shell...）
  + 进程列表可以嵌套
+ 命令后面加`&`可以后台运行（进程列表也可以加）
+ `jobs`显示后台作业信息
  + `-l`显示进程pid
+ 协程（在后台生成一个子shell，并在这个子shell中执行命令）
  + 默认名写法`coproc sleep 10`
  + 自定义名写法`coproc My_Job { sleep 10; }`
### 3.3 理解shell的内建命令
+ 外部命令会创建一个子进程运行（衍生），内建命令不会，所以内建命令效率更高
+ `which`用来查找一个命令的绝对路径（只能用来查找PATH环境变量中出现的路径下的可执行文件）
+ `type`查看一个命令是否为内建命令
  + `-a`如果该命令有多个版本则都显示
+ `history`历史命令列表
  + `~/.bash_history`历史命令保存文件
  + `-a`强制刷新文件
  + `-n`强制读取文件
  + `!!`最近一条命令 `!-n`最近第n条命令 `!n`第n条命令
+ `alias`用来设置指令的别名
  + 例：`alias ll=‘ls -l’`
  + `-p`查看当前可用的别名
  + 使用绝对路径的命令则不会被alias
+ `unalias`解除别名
## 四、Linux环境变量
> bash shell用一个叫作环境变量（environment variable）的特性来存储有关shell会话和工作环境的信息。这项特性允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。  
> 在bash shell中，环境变量分为两类：
> + 全局变量：全局环境变量对于shell会话和所有生成的子shell都是可见的。
> + 局部变量：局部变量则只对创建它们的shell可见。  
### 4.1 查看环境变量
+ `printenv`查看全局变量
  + 后跟环境变量名，可查看个别环境变量的值。例：`printenv HOME`
+ `env`查看全局变量（`env`有`printenv`没有的功能）
+ 引用某个环境变量的值，在变量前面加`$`
  + `echo $HOME`使用echo显示变量值
  + `ls $HOME`变量作为命令行参数
+ `set`显示所有环境变量，包括局部变量、全局变量以及用户定义变量
### 4.2 设置环境变量
+ 规范：局部变量使用小写字母命名，全局变量使用大写字母命名
+ `my_variable=Hello`创建局部变量
  + 等号两边不能有空格
  + 变量名只能由英、数字以及下划线组成，而且不能以数字开头
  + `my_variable="Hello World"`当变量内容带有特殊字符时（例如空格），需要加上单引号，内容中带有单引号用双引号
+ `export my_variable`创建全局变量
  + 子shell中对全局变量的修改，不会反映到父shell中
+ `unset my_variable`删除环境变量
  + 子shell中对全局变量的删除，不会反映到父shell中
+ bash shell有一些默认的系统环境变量，这些变量已经定义好了（但不一定有值）
  + 例：`HOME` `PATH` `BASH_ENV` `BASH_VERSINFO` `LOGNAME`
+ `PATH`环境变量定义了用于进行命令和程序查找的目录（使用外部命令时，shell必须搜索系统来找到对应的程序）
  + `PATH`中多个目录由`:`分隔
  + `PATH=$PATH:/home/christine/Scripts`在原有的`PATH`中继续增加目录
+ 以上方法对环境变量的修改只能持续到退出或重启系统
### 4.3 持久化环境变量
+ 启动shell的三种方式
  1. 登录时作为默认登录shell
  2. 作为非登录shell的交互式shell
  3. 作为运行脚本的非交互shell
+ 登录shell
  1. `/etc/profile`bash shell默认主启动文件（登录系统时，执行该文件中命令）
    + 导出了一些系统环境变量
    + 遍历执行`/etc/profile.d`中所有`sh`文件（一种环境变量持久化思路，不推荐直接改主启动文件）
  2. 根据登录的用户来决定的启动文件（在用户的`HOME`目录下）
    + `$HOME`和`~`的作用一样，表示当前用户的主目录
    + shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略
      1. `.bash_profile`
      2. `.bash_login`
      3. `.profile`
    + 以上文件一般会间接调用`.bashrc`文件
+ 交互式shell进程，执行`.bashrc`文件
  + 执行`/etc/bashrc`文件
  + 为用户提供一个定制自己的命令别名和私有脚本函数的地方
+ 非交互式shell，检查`BASH_ENV`环境变量，该环境变量指定了启动时要执行的文件
### 4.4 数组变量
+ `mytest=(one two three four five)`定义一个数组变量
+ `echo $mytest`只会展示数组变量的第一个值
+ `echo ${mytest[2]}`展示数组变量索引是2的值（从0开始）
+ `echo ${mytest[*]}`展示整个数组
+ `mytest[2]=seven`改变某个索引的值
+ `unset mytest[2]`删除某个索引的值（删除后那个位置上的值是空的，但是还在）
+ `unset mytest`删除整个数组
## 五、Linux文件权限
### 5.1 管理权限相关文件
#### 5.1.1 /etc/passwd
1. 登录用户名
2. 用户密码（x）
3. 用户账户的UID（数字形式）
4. 用户账户的组ID（GID）（数字形式）
5. 用户账户的文本描述（称为备注字段）（findger注释说明）
6. 用户HOME目录位置
7. 用户的默认shell
#### 5.1.2 /etc/shadow
1. 登录用户名（与`/etc/passwd`中的登录用户名对应）
2. 加密后的密码
3. 自上次修改密码后过去的天数密码（自1970年1月1日开始计算）
4. 多少天后才能更改密码
5. 多少天后必须更改密码
6. 密码过期前提前多少天提醒用户更改密码
7. 密码过期后多少天禁用用户账户
8. 用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）
9. 预留字段给将来使用
#### 5.1.3 /etc/group
1. 组名2. 组密码3. GID4. 属于该组的用户列表
#### 5.1.4 /etc/gshadow (略)
### 5.2 管理用户/组相关命令
1. `useradd`添加新用户
    + `-D`配置新用户的系统默认值（存储在`/etc/default/useradd`中）
2. `userdel`删除用户
    + `-r`删除用户的HOME目录以及邮件目录
    + 如果删除的用户创建过文件，则用户删除后原文件的所属主会变成未被占用的UID，所属组会变成未被占用的GID
3. `usermod`用户账户修改
    + `-l`修改用户账户的登录名
    + `-p`修改账户的密码（注意这里填的是加密后的密码）
    + `-L`锁定账户，使用户无法登录
    + `-U`解除锁定，使用户能够登陆
    + `-g`更改用户账户默认组
    + `-G`添加组到用户账户的组列表
4. `passwd`更改密码（默认修改当前用户的密码）
    + `-e`强制用户下次登录时修改密码
5. `chpasswd`批量更新密码
    + 可以从标准输入流读取登录名和密码对（由`:`分隔）列表
6. `chsh`修改默认shell
    + `-s`指定shell
7. `chfn`修改备注字段（`finger`查看）
8. `chage`管理用户账户的有效期
9. `groupadd`创建新组
10. `groupdel`删除组
11. `groupmod`修改组
    + `-g`修改GID
    + `-n`修改组名
12. `gpasswd`修改组密码
    + `-r`移除组密码
    + `-R`组密码失效
13. `groups`查看属于什么用户组
14. `su`切换用户
    + `-`切换用户后跳到该用户的家目录
15. `newgrp`临时切换组
16. `sudo`执行一个root才能执行的命令
    + 别的用户使用`sudo`，需要`visudo`命令编辑`/etc/sudoers`
### 5.3 管理文件权限相关命令
> 粘着位（sticy bit）：普通文件的sticky位会被linux内核忽略，目录的sticky位表示这个目录里的文件只能被owner和root删除。如果用户对目录有写权限，则可以删除其中的文件和子目录，即使该用户不是这些文件的所有者，而且也没有读或写许可。设置了该位后，其它用户就不可以删除不属于他的文件和目录。但是该目录下的目录不继承该权限，要再设置才可使用。
> 文件权限码：八进制高位到低位分别代表读(r)写(w)执行(x)，即全权限为7，读4，写2，执行1
1. `umask`默认文件权限
    + 第一位代表粘着位
    + 后三位代表文件权限（八进制文件权限码，三位分别代表所属主、所属组和其它用户权限）
    + 可以修改默认文件权限，文件全权限为666，目录全权限为777，减去umask中数值为默认权限
2. `chmod` 改变文件权限
    + `-R`递归改变权限
    + 3位八进制文件权限码（也可使用4位八进制值，见共享文件部分）
    + `u`用户`g`组`o`其它`a`所有，`+`增加权限`-`减少权限`=`将权限设置成后面的值，`r`读`w`写`x`执行
3. `chown`改变文件主/组
    + `-R`递归改变权限
    + `用户名`只改变主（只有`root`能改）
    + `用户名.组`改变主和组
    + `.组`只改变组（属主可修改，但要求属主是原属组和目标属组的成员）
    + `用户名.`改变主和组（主和组名相同时可用）
4. `chgrp`改变文件组
5. `chattr`修改文件的特殊属性
6. `lsattr` 列出文件/目录的特殊属性
### 5.4 共享文件
> Linux还为每个文件和目录存储了3个额外的信息位。
> + 设置用户ID（SUID）：当文件被用户使用时，程序会以文件属主的权限运行。
> + 设置组ID（SGID）：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。
> + 粘着位：进程结束后文件还驻留（粘着）在内存中。  
> 以上三位组成一位八进制值，可通过chmod直接指定，也可使用符号模式的`s`（第三位`t`）  
+ 例：将`testdir`目录设置为共享目录
    1. `mkdir testdir`创建目录
    2. `chgrp shared testdir`将目录用户组改为共享组（自己约定的）
    3. `chmod g+s testdir`SGID位置位
    4. `umask 002`修改默认权限，新文件对所属组可写
## 六、管理文件系统
### 6.1 Linux文件系统
#### 6.1.1 基本的Linux文件系统
+ `ext`扩展文件系统（extended filesystem），采用索引节点系统来存放虚拟目录中所存储文件的信息
+ `ext2`第二代扩展文件系统，文件大小2G变为2TB（`ext2`后期版本增加到了32TB），通过按组分配磁盘块来减轻碎片化
#### 6.1.2 日志文件系统
|方法|描述|
|:-:|:-:|
|数据模式|索引节点和文件都会被写入日志；丢失数据风险低，但性能差||有序模式|只有索引节点数据会被写入日志，但只有数据成功写入后才删除；在性能和安全性之间取得了良好的折中||回写模式|只有索引节点数据会被写入日志，但不控制文件数据何时写入；丢失数据风险高，但仍比不用日志好|
+ `ext3`，默认用有序模式的日志功能
+ `ext4`，支持数据压缩和加密，支持区段（extent）的特性，引入块预分配技术（block preallocation）
+ `ReiserFS`，只支持回写日志模式，可以在线调整已有文件系统的大小，支持尾部压缩（tailpacking）技术
+ `Journaled File System(JFS)`，默认用有序日志模式，采用基于区段的文件分配，减少存储设备上的碎片
+ `XFS`，采用回写日志模式，可以在线调整已有文件系统的大小（只能扩大）
#### 6.1.3 写时复制文件系统
> 写时复制（copy-on-write，COW）的技术：COW利用快照兼顾了安全性和性能。如果要修改数据，会使用克隆或可写快照。修改过的数据并不会直接覆盖当前数据，而是被放入文件系统中的另一个位置上。即便是数据修改已经完成，之前的旧数据也不会被重写。
+ `ZFS`
+ `Btrf`，B树文件系统
### 6.2 操作文件系统
#### 6.2.1 创建分区
> 分区可以按主分区（primary partition）或扩展分区（extended partition）创建。主分区可以被文件系统直接格式化，而扩展分区则只能容纳其他逻辑分区（logical partition）。扩展分区出现的原因是每个存储设备上只能有4个分区。可以通过创建一个扩展分区，然后在扩展分区内创建逻辑分区进行扩展。
+ `fdisk`交互式分区命令（拥有root权限，且指定正确的设备， `-l`列出系统中磁盘设备以及分区表，不加`-l`则进入另一个模式）
  + `m`显示命令选项
  + `p`显示当前分区表
  + `n`添加一个新分区
  + `w`将分区表写入磁盘
#### 6.2.2 创建文件系统
|工具|用途|
|:-:| :-: ||mkefs|创建一个ext文件系统||mke2fs|创建一个ext2文件系统||mkfs.ext3|创建一个ext3文件系统||mkfs.ext4|创建一个ext4文件系统||mkreiserfs|创建一个ReiserFS文件系统||jfs_mkfs|创建一个JFS文件系统||mkfs.xfs|创建一个XFS文件系统||mkfs.zfs|创建一个ZFS文件系统||mkfs.btrfs|创建一个Btrfs文件系统|
#### 6.2.3 文件系统的检查与修复
+ `fsck`检查和修复Linux文件系统
### 6.3 逻辑卷管理
> Linux逻辑卷管理器（logical volume manager，LVM）软件包正好可以让你在无需重建整个文件系统的情况下，轻松地管理磁盘空间
#### 6.3.1 逻辑卷管理布局
+ 物理卷（physical volume，PV）：每个物理卷都会映射到硬盘上特定的物理分区
+ 卷组（volume group，VG）：多个物理卷集中在一起可以形成一个卷组，视为一个物理硬盘，卷组提供了一个创建逻辑分区的平台
+ 逻辑卷（logical volume，LV）：逻辑卷为Linux提供了创建文件系统的分区环境，作用类似于Linux中的物理硬盘分区，Linux系统将逻辑卷视为物理分区
#### 6.3.2 使用Linux LVM
1. 创建物理卷
    + `fdisk` `t`改变分区类型（改成`8e`，表示这个分区将会被用作Linux LVM系统的一部分）
    + `pvcreate`创建物理卷（命令软件包名`lvm2`）
    + `pvdisplay`显示已创建的物理卷列表
2. 创建卷组
    + `vgcreate`创建卷组（指定卷组名、物理卷名）
    + `vgdisplay`显示创建的卷组的细节
3. 创建逻辑卷
    + `lvcreate`创建逻辑卷
      + `-l`指定空间大小（例：`100%FREE`） 
      + `-n`指定逻辑卷的名称
    + `lvdisplay`查看创建的逻辑卷的详细情况
4. 修改LVM

|命令|功能|
|:-:|:-:|
|vgchange|激活和禁用卷组||vgremove|删除卷组||vgextend|将物理卷加到卷组中||vgreduce|从卷组中删除物理卷||lvextend|增加逻辑卷的大小||lvreduce|减小逻辑卷的大小|
## 七、安装软件程序
### 7.1 包管理基础
+ 各种主流Linux发行版都采用了某种形式的包管理系统（package management system，PMS）来控制软件和库的安装
+ PMS目前还没有统一的标准工具  + 基于Debian的发行版（如Ubuntu和Linux Mint）使用的是`dpkg`命令  + 基于Red Hat的发行版（如Fedora、openSUSE及Mandriva）使用的是`rpm`命令+ Linux发行版都有各自基于这些命令的特定PMS工具
### 7.2 aptitude
+ `aptitude`进入命令全屏模式（无参数）
+ `aptitude show`显示特定包的详细信息
+ `dpkg -L`列出特定软件包所安装的全部文件
+ `dpkg --search`查找某个特定文件数据哪个软件包（必须用绝对文件路径）
+ `aptitude search`查找软件包
  + `p` `v`包可用，但未安装
  + `i` `u`已安装
  + `c`未安装（但有残留的配置信息）
+ `aptitude install`安装软件包
+ `aptitude safe-upgrade`更新软件包（无参数）
+ `aptitude remove`删除软件包（保留数据和配置文件）
+ `aptitude purge`删除软件包（不保留数据和配置文件）
+ `/etc/apt/sources.list`aptitude默认软件仓库配置文件
### 7.3 yum
+ `yum list installed`列出系统上已安装的包（可指定特定包名）
+ `yum list`列出所有可用包（可指定特定包名）
+ `yum provides`查看特定文件属于哪个包
+ `yum install`安装软件包
+ `yum localinstall`本地安装软件包（指定rpm安装文件）
+ `yum list updates`列出所有已安装包的可用更新
+ `yum update`更新软件包（不指定参数更新所有的，也可以指定）
  + `--skip-broken`忽略依赖关系损坏的那个包，继续去更新其他软件包
+ `yum remove`删除软件包（保留数据和配置文件）
+ `yum erase`删除软件包（不保留数据和配置文件）
+ `yum deplist`列出指定报的依赖
+ `yum clean all`包依赖损坏后尝试该命令后使用`yum update`
+ `yum repolist`查看用了哪些仓库
  + `/etc/yum.repos.d`文件配置
### 7.4 从源码安装
1. 下载源码包`wget`
2. 解压源码包`tar`
3. 系统配置`./configure`（查看解压后的`README.md`）
4. 编译`make`
5. 安装`make install`
## 八、vim编辑器
> vim有三种模式：普通模式、插入模式、命令行模式。普通模式按`i`进入插入模式；插入模式按`esc`回到普通模式；普通模式输入`:`进入命令行模式
1. 普通模式
    + 移动光标
      + `方向键`或`h`左`j`下`k`上`l`右
      + `Ctrl+F`下翻一屏`Ctrl+B`上翻一屏
      + `G`移到缓冲区的最后一行`num G`移到缓冲区第num行`gg`移到缓冲区第一行
    + 编辑数据（有些编辑命令允许使用数字修饰符来指定重复该命令多少次，例如：`2x` `5dd`）
    + 复制和粘贴
      + `p`粘贴到光标所在为止（最近删掉的内容或最近复制的内容） 
      + `yy`复制当前光标所在行
      + `yw`复制当前光标所在位置的单词
      + `y$`复制当前光标所在位置至行尾的内容
      + `v`进入可视化复制，移动光标选中索要复制区域，`y`完成复制

|命令|描述|
|:-:|:-:|
|x|删除当前光标所在位置的字符||dd|删除当前光标所在行||dw|删除当前光标所在位置的单词||d$|删除当前光标所在位置至行尾的内容||J|删除当前光标所在行行尾的换行符（拼接行）||u|撤销前一编辑命令||a|在当前光标后追加数据||A|在当前光标所在行行尾追加数据||r char|用char替换当前光标所在位置的单个字符||R text|用text覆盖当前光标所在位置的数据，直到按下ESC键|
2. 插入模式
3. 命令行模式
    + `q`如果未修改缓冲区数据，退出
    + `q!`取消所有对缓冲区数据的修改并退出
    + `w filename`将文件保存到另一个文件中
    + `wq`将缓冲区数据保存到文件中并退出
    + `/word`查找文本，`n`下一个`N`上一个
    + `s/old/new/`替换当行第一个old
    + `n,ms/old/new/g`替换行号n和m之间所有old
    + `%s/old/new/g`替换整个文件中的所有old
    + `%s/old/new/gc`替换整个文件中的所有old，但在每次出现时提示