# java基础笔记

## 一、java的基本元素
1. 空白分隔符
	+ 空格
	+ Tab键
	+ 换行符
2. 关键字
(不能用于变量名、类名、方法名等)
	+ 访问控制：  
	`private` `protected` `public`
	+ 类、方法、变量修饰符：  
	`abstract` `class` `extends` `final` `implements` `interface` `native` `new` `static` `strictfp` `synchronized` `transient` `volatile` `enum` `void` `var`
	+ 程序控制：  
	`break` `continue` `return` `do` `while` `if` `else` `for` `instanceof` `switch` `case` `default`
	+ 异常处理：  
	`try` `catch` `throw` `throws` `finally` `assert`
	+ 包相关：  
	`import` `package`
	+ 基本类型：  
	`byte` `short` `char` `int` `long` `float` `double` `boolean` 
	(单独的标识类型：`null` `ture` `false`)
	+ 变量引用：  
	`super` `this`
	+ 保留字：  
	`goto` `const`
3. 标识符
	+ 标识符是类、方法、变量的名字
	+ 命名规则：
		+ 可以包含数字、字母、下划线_、美元符号$，但是不能以数字作为开头
		+ 区分大小写
		+ 关键字是不能用作标识符的
		+ 可以使用中文，但不建议使用
4. 注释
	+ 单行注释：`//`
	+ 多行注释：`/* */`
	+ 文档注释：`/** */`  
	把关于程序的信息嵌入到程序内部，用javadoc工具来提取这些信息，形成帮助文档
5. 分隔符
(除了注释可以出现中文之外，其它的地方一律是英文(不建议中文变量名)，各种标点符号也必须是英文状态下的)
	+ `()` **圆括号**	 
		+ 定义方法的参数表
		+ 条件语句、循环语句中的条件定义
		+ 定义表达式的优先级
	+ `{}` **花括号**	 
		+ 初始化数组
		+ 定义程序块、类、方法
	+ `[]` **方括号**	 
		+ 声明数组类型
	+ `;` **分号**  
		+ 表示一个语句的结束
	+ `,` **逗号**  
		+ 变量声明时用于分隔多个变量
	+ `.` **点号**  
		+ 用于软件包和子包分隔
		+ 用于类、对象和变量、方法分隔
	
## 二、八大基本数据类型及数据类型转换
1. 基本数据类型
	+ 整型
		+ `byte`	1字节	-128~127
		+ `short`	2字节	-32768~32767
		+ `int`		4字节	正负21亿多(用的最多)
		+ `long`	8字节	特别大，当int不够用的时候，才会用long
	+ 字符型
		+ `char`	2字节	采用Unicode编码格式，支持中文
	+ 浮点型
		+ `float`	4字节	单精度
		+ `double` 	8字节	双精度(用的最多)
	+ 布尔型
		+ `boolean` 1字节	true真，false假
2. 自动转换
	+ `byte` `short` `char` **>** `int` **>** `long` **>** `float` **>** `double` 
	+ 目的类型比原来的类型要大
	+ 两种类型是相互兼容的
	+ `byte` `short` `char` 计算时会自动转换为`int`类型
3. 强制类型转换
	+ 浮点型转整型：把小数位截掉，保留整数位
	+ 长整型赋给短整型：去位

三.变量和常量
----------------------------------------
1 Java的变量
	变量：值可以改变的量
	命名规则：遵循标识符命名规则 尽量使用有意义的单词 一般首字母小写
	建议:英文的见名知意、驼峰命名法
2 Java的常量
	常量：值不能改变的量
	定义常量，使用final关键字
	习惯上常量都使用大写
	
四.赋值与初始化
----------------------------------------
1 赋值
	赋值：是给变量指定一个值或者是改变一个变量的值
2 初始化
	局部变量：必须显式的进行初始化
	实例变量和静态变量(类变量)：编译器可以自动对它们进行初始化(加了final的类变量必须初始化)
	boolean --> false  char --> \000  引用-->  null 其它都是0 0.0
	
五.字符串
----------------------------------------
1 字符串变量
	String类
2 字符串的连接
	可以用+来连接两个字符串，+在这里是一个连接运算符
	转义字符：每个转义字符都是由两个符号组成，但是编译器把他当成一个字符
	\n 换行符 光标移动到下一行
	\r 回车符 把光标移动到本行的开始处 (windows \r\n linux \n mac \r 表示换行)
	\t 制表符
3 字符串处理
	求子串 substring 含头不含尾
	测试字符串是否相等 equals (注意字符串常量 与new出来的对象的区别)
	字符串编辑 字符串常量的内容是不会变的，采用+连接符会生成新的字符串常量然后改变引用
4 字符串其他常用操作
	查阅API
	
六.运算符
----------------------------------------
1 基本算数运算符
	+ - * / %(取模运算不建议用于浮点型，结果可能不准确)
	对于精度高的运算，需要使用BigDecimal类型
2 算术赋值运算符
	+= -= *= /= %= (计算结果会进行数据类型的自动转换)
3 自增自减运算符
	++ --
	++i 先加再用 i++ 先用再加
4 关系运算符
	> >= < <= == !=
	返回值是boolean 一般用于判断语句中
5 逻辑运算符
	& 逻辑与 | 逻辑或 ! 逻辑非
	&&短路与 ||短路或
6 位运算符
	主要针对两个二进制数的位进行逻辑运算
	& 与 | 或 ~ 非 ^ 异或
	<< 左移运算 >> 右移运算(有符号) >>> 右移运算(无符号)
7 三元运算符
	condition?statement1:statement2
	该运算符的结果类型为statement1和statement2中最大的类型
8 运算符优先级
	算术运算符>关系运算符>逻辑运算符>三目运算符>赋值运算符
	()括号内优先级最高

七.流程控制
----------------------------------------
1 选择结构
	if语句
	switch语句 重点要理解有break和没有break的区别
2 循环结构
	while循环 do-while循环
	for循环 
	死循环 for(;;){} 比 while(true){} 效率高
3 break、continue、return的用法
	break语句		跳出当前循环
	continue语句	停止本次循环，继续执行剩下的循环
	return语句		从当前的方法中退出
	
八.数组
----------------------------------------
1 数组概述
	数组：就是一组数的集合，集合中的数据必须是相同类型的，并且每一个数组都有一个名字，也就是数组名，我们可以通过数组名来访问数组中的元素
2 创建数组
	ArrayType arrayName[]=new ArrayType[length];
	ArrayType[] arrayName=new ArrayType[length];//推荐写法
3 初始化方式
	方法一：int[] array=new int[5];array[0]=1;array[1]=2;array[2]=3;array[3]=4;array[4]=5;
	方法二：int[] array={1,2,3,4,5};(这种写法只能用于声明时初始化)
	方法三：int[] array;array=new int[]{1,2,3,4,5};
4 获取数组长度
	理解数组是一个对象
	arrayName.length
5 数组复制
	System. arraycopy(源数组,源数组起始位置,目标数组,目标数组起始位置,要复制的数组元素数量);
	目标数组=Arrays.copyOf(源数组，目标数组长度);
6 数组排序
	Arrays.sort();
7 多维数组
	Java中只存在一维数组，多维数组只不过是数组中的数组
	不规则数组创建
	方法一：int[][] array={{1},{1,2},{1,2,3}};
	方法二：int[][] array=new int[3][];array[0]=new int[]{1};array[1]=new int[]{1,2};array[2]=new int[]{1,2,3};

九.类的基础
----------------------------------------
1 类的概述
	类就是事物的集合和抽象。它所代表的是这类事物所共有的一些行为和属性
2 类的一般形式
	类是由属性和方法构成
3 方法
	如果方法没有返回值，则必须写void，不能省略
	如果有返回值，则定义的方法的类型必须和方法体内返回值的类型相同
 	主方法(程序的入口) private static void main(String[] args){}
4 构造方法
	作用是用于初始化参数
	当没有写构造方法时，编译器会默认加上无参构造方法
	写了构造方法时，编译器不会默认加上无参构造方法
	this(参数列表);  在构造方法可以调用本类其它构造器，但是只能引用一个构造方法且必须位于开始
	super(参数列表); 调用父类构造器
5 方法的重载
	1)发生在一个类中，方法名称相同，参数列表不同(参数类型不同、参数数量不同、参数次序不同)
	2)编译器在编译时会根据方法签名自动绑定调用的方法(方法名+参数列表)
	构造方法也可以重载
6 对象的创建和使用
	对象是类的实例
7 对象类型的参数传递
	Java中只有值传递 (引用类型存储的值是地址)
	引用类型作为参数，操作的是引用指向的堆内存中的对象
8 static关键字
	静态变量
		静态变量是属于类的，和对象没有关系
		非静态变量是属于某个对象的，每个对象都有该数据的副本，而静态变量只有一个
		访问静态变量可通过(类名.变量名)来访问的
	静态方法
		用static 修饰的方法称为静态方法
		访问静态方法可通过(类名.方法名)
		静态方法不能访问非静态变量和方法，非静态方法可以访问静态变量和方法
		静态属性和方法是在类加载的时候产生的，非静态属性和方法是在new的时候产生的
	静态常量
		public static final 类型 变量名=值;
9 final关键字
	使用final修饰过的都是不可改变的
	final修饰变量
		不可被重新赋值，否则编译报错
		恒定不变的属性，可以使用final来进行修饰，变量名建议全部大写
	final修饰方法
		不可被重写，重载不会受到限制
	final修饰类
		不可被继承，该类不能作为任何类的父类
10 包的介绍
	未命名包
	没有包的类(开头没有package的类)等效于在一个没有名字的包中
	其它包中的类是无法调用它们的，但是它们之间可以互相调用，也可以调用别的包中的类
	命名包
	package 包名(域名反写)
	
十.面向对象三大特征
----------------------------------------
1 封装
	属性私有化，方法公开化 private public get() set()
	1)类:封装的对象的属性和行为
	2)方法:封装了具体的业务逻辑功能行为
	3)访问控制修饰符:封装的具体的访问权限
2 继承
	extends只能继承一个类,Java不支持多重继承
	子类继承父类之后，子类可以调用父类的属性和方法，也可以重写父类的属性和方法，还可以增加自己的属性和方法
	重写(遵循"两同两小一大"原则)
	1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
	2)重写方法被调用时，看对象的类型
	注意:子类定义和父类相同名字的属性时的一些情况
	创建子类对象的过程就是从底层的基类开始往上，一层层地调用构造方法。
	在调用子类的构造器的时候，如果没有显示的写出super，那么编译器会在子类构造方法开头默认加上super()无参构造器 super();
	1)作用:实现代码的复用，减少代码的重复
	2)通过extends来继承，通过implements来实现
	3)单一继承，多接口实现
	4)传递性
3 多态
	所谓多态，实际上就是一个对象的多种状态
	父类的引用可以调用子类的对象，并且调用的是子类重写后的方法。遵循"运行期"绑定，看对象
	1)行为的多态、对象的多态
	2)向上造型(父类型的引用指向子类的对象,能点出来什么，看引用的类型)、强制类型转换、instanceof判断
	3)多态的表现形式:
		3.1)重写:根据对象来多态
		3.2)重载:根据参数来多态
		
十一.抽象类
----------------------------------------
1 抽象方法
	1)由abstract修饰
	2)只有方法的定义，没有具体的实现(连{}都没有)
2 抽象类
	1)由abstract修饰
	2)包含抽象方法的类必须是抽象类
      不包含抽象方法的类也可以声明为抽象类-----我乐意
	3)抽象类不能被实例化
	4)抽象类是需要被继承的，子类:
		4.1)重写所有的抽象方法------变不完整为完整
		4.2)也声明为抽象类----------一般不这样做	
	5)抽象类的意义:
		5.1)封装子类共有的属性和行为--------代码复用
		5.2)为所有子类提供了统一的类型------向上造型
		5.3)可以包含抽象方法，为所有子类提供统一的入口
			子类的具体实现不同，但方法的定义是一致的

十二.接口
----------------------------------------
1 接口
	1)是一种数据类型(引用类型)
	2)由interface定义的
	3)接口中只能包含常量和抽象方法(编译器默认添加 public static final 或 public abstract)
	4)接口不能被实例化
	5)接口是需要被实现(继承)的，实现类(子类):
      必须重写接口中的所有抽象方法
	6)一个类可以实现多个接口，用逗号分隔
      若又继承又实现时，应先继承后实现
	7)接口可以继承接口(可以继承好几个接口以,隔开)
	  如果这几个接口有相同的方法和相同的变量，那么相同的变量需要通过 接口名.变量名 的形式来访问，相同的方法不影响不必深究

十三.内部类
----------------------------------------
1 成员内部类
	1)类中套类，外面的类称为Outer，里面的类称为Inner
	2)内部类通常只服务于外部类，对外不具备可见性
	3)内部类对象通常都是在外部类中创建的(外面创建方法 Outer.Inner in=new Outer().new Inner();)
	4)内部类中可以直接访问外部类的成员(包括私有的)
	  内部类中有个隐式的引用指向了创建它的外部类对象 eg: 外部类名.this
2 匿名内部类(应用率高)
	1)若想创建一个类(子类)的对象，并且对象只被创建一次，
      此时该类不必命名，称为匿名内部类
	2)匿名内部类中访问外部的变量，该变量必须是final的
3 局部内部类
	在局部内部类里面可以访问外部类的所有成员变量
	局部内部类访问方法中的局部变量的时候，该布局变量必须声明为final类型
	为什么局部变量必须是final类型?变量生命周期问题
4 静态内部类
	在内部类前添加static修饰符
	静态内部类中可以声明static成员变量，非静态内部类中不可以
	静态内部类不可以使用外部类的非静态成员变量
	创建静态内部类的对象，不需要其外部类的对象(Outer.Inner in=new Outer.Inner();)
5 内部类的继承
	public class Test extends Outer.Inner{
		public Test(Outer out){
			out.super();
		}
	}
	class Outer{
		public class Inner{}
	}
	
十四.Java异常
----------------------------------------
1 什么是异常
	异常就是程序运行过程中所出现的不正常现象
	try 把可能发生异常的代码包起来，当发生异常时，将异常抛出 catch 捕获异常并处理 finally 不管是否发生异常，都会执行
	try catch finally 是可以嵌套使用的
	throw 手动抛出一个异常 throws 定义任何被调用方法的异常
    异常出现的原因：用户输入错误 代码的错误 环境的因素
	异常机制保证了程序的健壮性
2 异常的分类
	Error:它是Java运行时的内部错误以及资源耗尽错误。很难恢复，不期望用户来处理
	Throwable --> Error:IOError VirtualMachineError StackOverflowError OutOfMemoryError								
	         |--> Exception --> RuntimeException:运行时异常(编译器不会检测该异常，不用显式处理也可以编译通过):NullPointerException ClassCastException ArithmeticException IndexOutOfBoundsException NumberFormatException
						   |--> 非RuntimeException:由环境因素导致 ClassNotFoundException CloneNotSupportedException IOException
3 获取异常信息 try catch
	程序发生异常的时候，程序就直接从try语句块执行到catch语句块，不再继续执行try语句块中该语句后的语句
	try 不能单独出现，后面必须跟着catch或finally或两者都有
	return; 不会影响finally语句块的执行 System.exit(0);可以
4 异常声明 throws
	指一个方法不处理它所产生的异常，而是调用层次向上传递，谁调用的这个方法，谁来处理。
5 手动抛出异常 throw
	throw exception; 参数exception表示要抛出的异常对象，该对象是throwable类的子类，而且只能够是一个
6 异常链
	两个或者多个不同的异常出现在同一个程序中，并且会发生嵌套抛出，我们称之为异常链	
	exception1.initCause(exception2); 异常1是由异常2造成的
7 自定义异常
	自定义异常创建 1)继承Throwable 2)继承Exception
	自定义异常使用 自己定义的异常一般来说是用于throw
	
十五.线程
----------------------------------------
1 线程基本知识
	线程与进程
		进程:执行中的程序
		线程:轻量级的进程，线程本身不能单独运行，必须放在一个进程中才能执行
	Java的线程模型(线程五种状态)
		1)新建状态 New
			线程被创建之后便处于新建状态
		2)就绪状态 Runnable
			新建见状态的线程调用start()进入就绪状态
			阻塞状态的线程解除阻塞之后进入就绪状态
		3)运行状态 Running
			处于就绪状态的线程获得了CPU的资源，该线程就进入了运行状态
		4)阻塞状态 Blocked
			是一个正在运行的线程，因为一些原因让出CPU资源暂时中止而进入的状态
		5)终止状态 Dead
			正常终止
			强制终止：stop、destroy System.exit(0)
			异常终止：当线程执行过程中产生了异常，线程会终止
2 创建线程的方式
	1)继承Thread类
		继承Thread类，重写run()方法，调用start()方法执行线程
	2)继承Runnable类
		实现Runnable接口，实现run()方法，作为参数构造Thread对象，调用start()方法执行线程
	3)两种方法的比较
		因为Java是单继承，方法一限制较大
	4)线程池
		ExecutorService threadPool=Executors.newFixedThreadPool(2);
		threadPool.execute(runn);//runn是Runnable子类
		threadPool.shutdown();
3 多个线程并发执行
	Java对于线程启动后唯一能保证的是每个线程都被启动并且结束。但是对于哪个线程先执行，哪个后执行，什么时候执行，是没有保证的
4 Thread常用方法
	1)static Thread currentThread()	可以获取运行该方法的线程
	2)*static void sleep(long ms)	休眠方法，该方法可以将运行该方法的线程阻塞指定毫秒
	3)*static void yield()	暂停方法，释放调用该方法的线程的CPU资源，大家一起来抢(包括自己)
	4)*void join()	挂起方法，等待调用该方法的线程终止后再继续执行
	5)void setPriority(int newPriority) 设置线程优先级，Java中优先级高的线程有更大的可能性获得CPU，但不是优先级高的总是先执行，也不是优先级低的线程总是后执行
	6)void setDaemon(boolean on)	设置守护线程(后台线程)，当一个进程中的所有前台进程都结束时，进程结束，无论该进程中的守护线程是否还在运行都要强制将它们结束
	7)其它 getId() getName() getPriority() isDaemon() isAlive() isInterrupted() start() interrupt()
	*为线程调度三个方法
5 线程同步问题的由来
	1)线程同步问题的由来：多个线程共享资源并没有进行控制
		当多个线程并发访问同一资源时，由于线程切换时机不确定导致执行代码顺序的混乱，从而出现执行未按程序设计顺序运行导致出现各种错误，严重时可能导致系统瘫痪.
	2)同步问题Java的解决方案
		同步方法：synchronized 方法声明{}
		当线程进入同步方法的时候，会获得同步方法所属对象的锁，一旦获得对象锁，则其他线程不能再执行被锁对象的其他任何同步方法。只有在同步方法执行完毕之后释放了锁，其他线程才能继续执行
		同步块：  synchronized(资源对象){//需要进行同步的方法}
		Lock:private Lock lock = new ReentrantLock();	lock() tryLock() unlock() Condition newCondition() await() signal() signalAll()
	3)StringBuiler不是线程安全的，当多个线程操作同一个字符串时应当使用StringBuffer
	  对于集合而言，常用的实现类：ArrayList,LinkedList,HashSet它们都不是线程安全的
	  Collections可以将现有的集合转换为线程安全的 listName=Collections.synchronizedList(listName);
6 死锁问题
	例：A线程需要申请资源1才能继续执行，而资源1被B线程所占有
		B线程需要申请资源2才能继续执行，而资源2被A线程所占有
7 生产者和消费者模型
	永远在while循环中对条件进行判断而不是if语句中进行wait条件的判断
	使用NotifyAll而不是使用notify
	了解对象锁与类锁

十六.枚举
----------------------------------------
1 枚举类的定义
	在某些情况下，一个类的对象是有限而且固定的。例如季节类，只能有4个对象
2 手动实现枚举类
	1)因为枚举类的对象是有限个，所以不能在类的外部创建类的对象				private修饰构造器
	2)因为对象是固定的，所以属性是常量										属性使用private final修饰
	3)在类的内部创建对象，但需要在类的外部能够访问到该对象，而且还不能修改	把该类的所有实例都使用public static final来修饰
3 JDK1.5新增enum关键字定义枚举类
	1)使用enum定义的枚举类默认继承了java.lang.Enum类
	2)枚举类的构造器只能使用private访问控制符
	3)枚举类的所有实例必须在枚举类中第一行显示列出(,分割;结尾) 列出的实例系统会自动添加public static final修饰
	4)所有的枚举类都提供了一个values方法，该方法可以很方便地遍历所有的枚举值
	5)JDK1.5中可以在switch表达式中使用枚举类的对象作为表达式，case子句可以直接使用枚举值的名字，无需添加枚举类作为限定
	6)若枚举只有一个成员，则可以作为一种单例模式的实现方式
	7)枚举类使用private final修饰的属性应该在构造器中为其赋值。枚举类显式的定义了带参数的构造器，则在列出枚举值时也必须对应的传入参数
4 枚举类可以实现一个或多个接口，可以对每个枚举类的对象分别实现方法。在列表中用{}实现
	也可以实现一个用 对象.toString().equals("枚举名字") 判断执行不同的代码块
5 使用一个字符串获取枚举类对象，可以使用valueof方法

十七.注解 Annotation
----------------------------------------
1 注解概述
	可在类、方法、属性上进行标记
	又称元数据(MetaData)，其实就是代码里的特殊标记，可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息
2 基本的Annotation
	@Override			限定重写父类方法，该注释只能用于方法
	@Deprecated			用于表示某个程序元素(类，方法)已过时
	@SuppressWarnings	抑制编译器警告
3 自定义注解 有成员变量-->元数据 无成员变量-->标记
	1)@interface关键字
	2)使用类似于接口方法声明的方式来定义注解的属性:其中返回值称为属性的类型，方法名为属性的名称
	3)默认属性值用default关键字
4 提取Annotation信息 反射机制
5 JDK的元Annotation 修饰其他Annotation定义
	@Retention 指定Annotation可以保留多长时间 value RententionPolicy
	@Target 指定被修饰的注解能用于修饰哪些程序元素 value ElementType
	@Documented 注解可被javadoc工具提取成文档
	@Inherited 被它修饰的注解具有继承性，被子类自动继承
	
十八.泛型
----------------------------------------
1 什么是泛型
	1)泛型是JDK1.5新添加的特性
	2)泛型就是将类型参数化
	3)提高类型的安全并能简化类型转换的过程。在泛型处理过程中，所有的类型转换都是自动和隐式的
	泛型将类型的错误提前到了编译期
2 没有泛型的情况
	可以使用Object类和类型强转来实现类似的功能，但是
	数据类型转换比较复杂
	在转换中会产生不安全的因素
3 泛型的基本写法
	以尖括号<参数类型>的形式放在类名后面
	泛型处理的必须是类的类型，不能用它来处理int、long等基本类型
	Gen<T>{ //类
		T obj;  //属性类型
		Gen(T obj){}//参数类型
		T getObj(){}//返回值类型
	}
4 使用两个或多个类型参数 <T,E> 字母随便
5 类型边界 
	<T extends 类> 类就为T的上界
	可以获得类型安全
	可以让类型有进一步的操作能力
6 通配符的使用
	上边界类型通配符（<? extends 父类型>）：因为可以确定父类型，所以可以以父类型去获取数据（向上转型）。但是不能写入数据。
	下边界类型通配符（<? super 子类型>）：因为可以确定最小类型，所以可以以最小类型去写入数据（向上转型）。
	无边界类型通配符（<?>） 等同于 上边界通配符<? extends Object>，所以可以以Object类去获取数据，但意义不大。
	下边界类型通配符（<? super 子类型>）下边界通配符<? super 子类型> + 上边界通配符<? extends Object>，所以可以以Object类去获取数据，但意义不大。
7 泛型方法
	在非泛型类中也可以有泛型方法
	定义泛型方法的格式:
		修饰符 方法类型 <参数类型列表> 返回值类型 方法名(参数列表){}
	参数类型由方法运行时所传参数类型决定
8 泛型类之间的继承
	定义泛型子类，声明中必须包含其父类的类型参数。即便在子类中不使用，仍然要在参数列表中指定它
	GenChild<T,V,K> extends GenParent<T>
9 泛型类与非泛型类之间的继承
	父类是泛型类，子类不是泛型类。如果子类继承了带泛型的父类，则子类必须得是泛型类，并且包含父类的泛型(也可以当父类不是泛型类来写，但是意义不大)
	public class GenChild<T> extends GenParent<T>
	父类不是泛型类，子类是泛型类，正常写就可以，没有强制性的要求
	public class GenChild<T> extends GenParent
10 泛型继承中方法的覆盖
	对于泛型类的继承来说，方法重写同样适用
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
十九.基本数据类型的封装类，Object类
----------------------------------------
1 byte		Byte
  short		Short
  int		Int
  long		Long
  float		Float
  double	Double	
  char		Character
  boolean	Boolean
2 自动装箱与拆箱
	基本数据类型 转换为 封装类型：装箱	Integer i=Integer.valueOf(d);
	封装类型 转换为 基本数据类型：拆箱	int d=new Integer(123).intValue();
3 Object类(Java所有类的父类)
	toString() equals() clone()(重写该方法的类需要实现Cloneable接口) finalize()
	System.gc() 建议JVM回收垃圾，但是无法控制，因为这是由JVM的算法决定的
4 Math类 double random()
